---
title: 线性算法
date: 2023-03-23
sidebar: 'auto'
categories:
 - 算法
tags:
 - JavaScript
 - TypeScript
publish: true
---
## 线性查找法
拿数组举例：就是给定一个目标值，和一个数组，然后从索引0开始逐一比较，找到返回目标索引，找不到返回-1
``` ts
interface ISearch<T> {
  (arr: T[], target: T): number
}
const lineSearch: ISearch<number> = () =>{
  let position = -1;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      position = i;
      return position;
    }
  }
  return position;
}

const arr: number[] = [1, 2, 3, 4, 5, 6, 7, 8];
const target = 8;

const result = lineSearch(arr, target);

console.log(result);


class LineSearch {
  static search<T> (arr: T[], target: T): number {
    let position = -1;
    for(let i = 0; i < arr.length; i++) {
      if (arr[i] === target) {
        position = i;
        return position
      }
    }
    return position;
  }
}

const result2 = LineSearch.search(['2', 1, '3'], '3')
console.log(result2)
```
在线性查找算法中，循环不变量通常是指在每次循环迭代中，要查找的元素都在未被查找的部分中。具体而言，循环不变量包括以下三点：
初始化：当循环开始时，未被查找的数组部分包括整个数组。`arr[0...i)`
保持：在每次循环迭代中，需要检查未被查找的数组部分中是否包含要查找的元素，如果包含，则停止循环；如果不包含，则继续查找。`if (arr[i] === target)`循环体维持循环不变量
终止：当循环结束时，要么找到了要查找的元素，要么未找到。如果未找到，则表示要查找的元素不存在于数组中。

通过以上循环不变量，我们可以保证在线性查找算法中的正确性。如果数组中包含要查找的元素，那么最坏情况下的时间复杂度为O(n)，其中n是数组中元素的个数。如果数组中不存在要查找的元素，那么时间复杂度同样是O(n)。
## 循环不变量
循环不变量是一中在循环结构中使用的技巧，指在一个循环变量中需要保持不变的某个条件或者性质，通常分为三部部分：<br>
+ 初始化：再循环开始时，循环不变量需要成立
+ 保持：每次迭代中，循环不变量要保持成立
+ 终止：循环结束时，循环不变量需要成立，并且可以用于证明算法的正确性
利用循环不变量可以更好的理解算法的正确性，以及实现算法时进行调优。循环不变量在算法分析和设计中非常重要，是验证算法正确性的一个关键步骤。
## 时间复杂度
时间复杂度是算法运行所需要的时间随着数据规模增长而增长的量度。它通常用“大O符号”来表示，因此也被称为“大O时间复杂度”。时间复杂度描述的是算法运行所需的计算操作次数，而不是真实的时间。因为在不同的计算机或不同的程序环境中，同样的算法运行的时间是不同的。通常来说，时间复杂度越低，算法的执行效率越高。
常见的时间复杂度从小到大排序如下：<br>

+ O(1)：常数时间复杂度，算法的运行时间不随着数据规模的增长而增长，是最优秀的时间复杂度。
+ O(log n)：对数时间复杂度，常见于二分查找等分治算法中，运行时间增长缓慢。
+ O(n)：线性时间复杂度，常见于简单查找、遍历等算法中，运行时间与数据规模成正比。
+ O(n log n)：常见于快速排序、归并排序等分治算法中，运行时间比线性时间复杂度稍微慢一些。
+ O(n^2)：平方时间复杂度，常见于简单排序算法、动态规划等中，运行时间随着数据规模增长而快速增长。
+ O(2^n)：指数时间复杂度，常见于穷举算法等中，运行时间增长非常快，随着数据规模的增长呈指数级增长。

需要注意的是，时间复杂度只是算法的一个理论分析，实际应用中还需要考虑一些其他因素，例如算法的常数项、数据的特殊性等等。