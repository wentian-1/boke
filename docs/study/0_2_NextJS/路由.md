---
title: 【Next】路由
date: 2024-02-19
sidebar: 'auto'
categories:
 - Next
tags:
 - Next
publish: true
---
## 前言
路由是一个应用程序的基础和骨架，是应用重要的组成部分。在NextJs中，目前有两套解决方案，一开始的[pages router](https://nextjs.org/docs/pages/building-your-application/routing)以及在13版本中新引入的[app router](https://nextjs.org/docs/app/building-your-application/routing)，两套方案是兼容的。但是注意：app router的优先级高于pages router，跨目录的路由不要使用相同的名字，防止构建错误以及冲突。

## App Router
Next.js的路由是基于文件系统的，在app里面每一个目录都是一个url的组成部分。举个例子
<img :src="$withBase('/imgs/0_2_NextJS/route1.jpg')" alt=""><br/>
这个时候就会生成一个user/detail的路由，其中app文件夹相当于/
## 定义路由
正如上面所说，每个目录就代表一个路由段，嵌套路由的视线就是见目录相互嵌套就可。值得注意的是官方特定了几个特殊的文件名字，以便于区分页面，布局。。。和自定义组件之间的区别，这也是比`pages router`优势之一。

## 页面
正如刚才所说，`page.jsx`就是Next.js的约定之一，他是一个页面的入口文件。由于Next.js是支持React和TS的，所以文件名的后缀可以是`js, jsx, tsx`。
在app目录下创建一个`page.jsx`,内容如下
<img :src="$withBase('/imgs/0_2_NextJS/route3.jpg')" alt=""><br/>
`app/page.jsx`    
::: warning
这里由于没有创建根布局，Next.js会默认给我们创建一个
:::
```jsx
export default function Page() {
	return <h1>你好，Next.js</h1>;
}
```
在浏览器中打开地址，就会看到
<img :src="$withBase('/imgs/0_2_NextJS/route2.jpg')" alt=""><br/>
之前提到，路由嵌套就是目录嵌套，`page.jsx`是页面的入口，所以在app，目录下创建`user/detail/page.jsx`，内容如下
<img :src="$withBase('/imgs/0_2_NextJS/route4.jpg')" alt=""><br/>
`app/user/detail/page.jsx`
```jsx
async function getName() {
	return {name: "yfc"};
}

export default async function Page() {
	const {name} = await getName();
	return <h1>你好，我的名字是{name}</h1>;
}
```
打开浏览器访问地址`http://localhost:3000/user/detail`就会看到如下页面
<img :src="$withBase('/imgs/0_2_NextJS/route5.jpg')" alt=""><br/>
:::warning
注意每一个路由要对应一个page页面，否则就会404
:::

## 布局
布局是多个路由之间共享的UI，并且在导航时候保留状态，保持交互性并且不重新渲染。
正如page一样，布局也是Next内定的一个特殊文件，名字就是`layout`
### 定义布局
之前定义页面时候曾提到，我们不手动创建layout文件的话，Next.js会自动给我们创建一个。接下来我们删除自动创建的，手动创建一个。
在app目录下新建`layout.jsx`，且新增如下内容
<img :src="$withBase('/imgs/0_2_NextJS/route6.jpg')" alt=""><br/>
`app/layout.jsx`
```jsx
export default function RootLayout({children}) {
	return (
		<html lang="en">
			<body>
				<h1>这是根布局</h1>
				<div>{children}</div>
			</body>
		</html>
	);
}
```
打开页面就会看到
<img :src="$withBase('/imgs/0_2_NextJS/route7.jpg')" alt=""><br/>
::: warning
+ Next.js中，必须要有一个根布局文件，存在与app目录下
+ 根布局文件中，必须要有`html body`标签且只限根布局拥有
+ 如果没有根布局，Next.js会自动创建
:::

### 布局嵌套
页面能嵌套，当然布局也可以，嵌套的规则跟路由保持一致。每一个路由必须对应一个`page.jsx`文件，这个时候跟page文件同级的`layout.jsx`文件就是，当前目录的布局，这也意味着它们通过props包装子布局children。    
现在在`app/user`目录下创建一个`layout.jsx`文件，内容如下
<img :src="$withBase('/imgs/0_2_NextJS/route8.jpg')" alt=""><br/>
`app/user/layout.jsx`
```jsx
export default function UserLayout({children}) {
	return (
		<div>
			<h2>这是User布局</h2>
			<div>{children}</div>
		</div>
	);
}
```
打开链接`http://localhost:3000/user/detail`就会看到如下页面
<img :src="$withBase('/imgs/0_2_NextJS/route9.jpg')" alt=""><br/>

## 模板
模板跟布局类似，他们都可以包装子布局或者页面，举个例子，在app目录下创建`user/template.jsx`文件，并添加一下代码
<img :src="$withBase('/imgs/0_2_NextJS/route10.jpg')" alt=""><br/>
`app/user/template.jsx`
```jsx
export default function UserTemplate({children}) {
	return (
		<div>
			<h2>这是User模板</h2>
			<div>{children}</div>
		</div>
	);
}
```
打开地址`http://localhost:3000/user/detail`就会看到如下页面
<img :src="$withBase('/imgs/0_2_NextJS/route11.jpg')" alt=""><br/>
由上图也可以看出如果布局和模板同时存在，布局将嵌套模板。
但是**模板不会保留状态**，就是说用户在共享模板之前的路由切换的时候，将安装新的组件实例，下面举例说明。
<img :src="$withBase('/imgs/0_2_NextJS/route12.jpg')" alt=""><br/>
+ 新增`app/user/center/page.jsx`
```jsx
export default function Page() {
	return <h2>这是center页面</h2>;
}
```
+ 新增`app/user/config/page.jsx`
```jsx
export default function Page() {
	return <h2>这是config页面</h2>;
}
```
+ 修改`app/user/layout.jsx`
```jsx
"use client";
import {useState} from "react";
import Link from "next/link";
export default function UserLayout({children}) {
	const [count, setCount] = useState(0);
	return (
		<div>
			<Link href="/user/center">center</Link><br/>
			<Link href="/user/config">config</Link><br/>
			<Link href="/user/detail">detail</Link>
			<h2>这是User布局 count: {count}</h2>
			<button onClick={() => setCount(count + 1)}>加</button>
			<div>{children}</div>
		</div>
	);
}
```
+ 修改`app/user/template.jsx`
```jsx
"use client";
import {useState} from "react";

export default function UserTemplate({children}) {
	const [count, setCount] = useState(0);
	return (
		<div>
			<h2>这是User模板 count: {count}</h2>
			<button onClick={() => setCount(count + 1)}>加</button>
			<div>{children}</div>
		</div>
	);
}
```
打开地址`http://localhost:3000/user/center`
<img :src="$withBase('/imgs/0_2_NextJS/route13.jpg')" alt=""><br/>
布局和模板各加3
<img :src="$withBase('/imgs/0_2_NextJS/route14.jpg')" alt=""><br/>
切换到config路由
<img :src="$withBase('/imgs/0_2_NextJS/route15.jpg')" alt=""><br/>
会发现，这个时候模板的计数已经变为0而layout的依然存在。   
::: warning
注意在template.jsx和layout.jsx文件的最上面一行`'use client'`这是标记文件是客户端运行的代码，因为上面的点击事件无法再服务端运行。Next.js中，客户端渲染时可选的，所以需要明确声明React在客户端上渲染哪些组件。默认情况下Next.js使用服务端组件，自动实现服务端渲染，无需额外配置。
:::

## 加载界面
在React中可以使用Suspense配合lazy实现加载的loading效果，在Next.js中已经规定好了`loading.jsx`实现加载效果，他跟布局，模板和页面一样，也是内置的特殊文件。    

而Next.js的loading是借助于React的`Suspense`实现的，就是当路由发生变化的时候，立刻展示`fallback UI`，等加载完成后，展示数据。

关于`Suspense`是如何控制`fallback UI`的展示的原理也很简单。
+ 当react在beginWork阶段遇到Suspense组件时候，会将动态组件作为子节点
+ 当遍历到动态组件时候，动态组件就会抛出一个promise异常，react捕获promise，将其then方法中添加一个回调，作用是触发Suspense组件的更新，并将下一次遍历的组件设置为Suspense
+ 再次遍历Suspense后会把动态组件和fallback UI都生成，虽然动态组件作为Suspense 的直接子节点，但是Suspense会在beginWork 阶段直接返回fallback UI。使得直接跳过 动态组件 的遍历。因此此时 动态组件 必定没有加载完成，所以也没必要再遍历一次。本次渲染结束后，屏幕上会展示 fallback UI 的内容。
+ 当动态组件组件加载完成后，会触发步骤2中then，使得在Suspense上调度一个更新，由于此时加载已经完成，Suspense 会直接渲染加载完成的动态组件组件，并删除fallback UI组件。

基本逻辑可以总结如下：

+ 抛出异常
+ react捕获，添加回调
+ 展示fallback UI
+ 加载完成，执行回调
+ 展示加载完成后的组件

原理大致清楚了，现在看看用法吧
新建`app/user/loading.jsx`文件，内容如下
<img :src="$withBase('/imgs/0_2_NextJS/route16.jpg')" alt=""><br/>
`app/user/loading.jsx`
```jsx
export default function UserLoading() {
	return <div>加载中，，，，请稍后</div>;
}
```
修改`app/user/detail.jsx`文件，内容如下
<img :src="$withBase('/imgs/0_2_NextJS/route17.jpg')" alt=""><br/>
`app/user/detail.jsx`
```jsx {2}
async function getName() {
	await new Promise((resolve) => setTimeout(resolve, 3000));
	return {name: "yfc"};
}

export default async function Page() {
	const {name} = await getName();
	return <h1>你好，我的名字是{name}</h1>;
}
```
打开地址`http://localhost:3000/user/detail`
<img :src="$withBase('/imgs/0_2_NextJS/route18.jpg')" alt=""><br/>
3秒后
<img :src="$withBase('/imgs/0_2_NextJS/route19.jpg')" alt=""><br/>
注意在`app/user/detail.jsx`中，发现返回了一个async函数，当然不止这一种方式，使用React的`use`函数一样可以，
修改`app/user/detail.jsx`文件
```jsx {1,8} 
import {use} from "react";
async function getName() {
	await new Promise((resolve) => setTimeout(resolve, 3000));
	return {name: "yfc"};
}

export default function Page() {
	const {name} = use(getName());
	return <h1>你好，我的名字是{name}</h1>;
}
```

## 定义404
在Next.js中又默认的404页面，当访问的路由不存在时候，展示如下页面
<img :src="$withBase('/imgs/0_2_NextJS/route20.jpg')" alt=""><br/>
如果想要覆盖默认的404也很简单，在app目录下创建`not-found.jsx`即可
`app/not-found.jsx`
```jsx
import Link from "next/link";
export default function NotFound() {
	return (
		<div>
			<h1>Oh no!</h1>
			<Link href="/">返回首页</Link>
		</div>
	);
}
```
访问一个不存在的路由就会出现一下效果。

<img :src="$withBase('/imgs/0_2_NextJS/route21.jpg')" alt=""><br/>

## 定义错误
`error.jsx`跟之前的约定一样，也是Next.js内定的一个特殊文件，用来捕获错误来展示备用的UI。举个例子，代码如下
新建`app/user/error.jsx`
<img :src="$withBase('/imgs/0_2_NextJS/route22.jpg')" alt=""><br/>
`app/user/error.jsx`
```jsx
"use client";
import {useEffect} from "react";

export default function UserError({error, reset}) {
	useEffect(() => {
		console.log(error.message);
	}, [error]);
	return (
		<div>
			<h2>User 里面出现了问题</h2>
			<button onClick={() => reset()}>尝试回复</button>
		</div>
	);
}
```
修改`app/user/center/page.jsx`
```jsx {1-2,3,8-17}
"use client";
import {useState} from "react";
export default function Page() {
	const [arr, setArr] = useState([1, 2]);
	return (
		<div>
			<h2>这是center页面</h2>
			{arr.map((item) => (
				<p key={item}>{item}</p>
			))}
			<button
				onClick={() => {
					setArr(true);
				}}
			>
				制造错误
			</button>
		</div>
	);
}
```
打开地址`http://localhost:3000/user/center`，呈现如下页面
<img :src="$withBase('/imgs/0_2_NextJS/route23.jpg')" alt=""><br/>
点击制造错误
<img :src="$withBase('/imgs/0_2_NextJS/route24.jpg')" alt=""><br/>
然后有时候错误是可以重新修复的。所以Next.js在错误组件中传入了`reset`函数，此函数会重新刷新错误边界里的内容，成功的话就会重新渲染内容。
点击尝试修复按钮
<img :src="$withBase('/imgs/0_2_NextJS/route25.jpg')" alt=""><br/>
::: warning
+ error.js必须是客户端组件，意味着必须加`use client`
+ 也不会处理同级别的layout.jsx中的错误，因为同级别的话是layout.jsx的子级
+ 要处理根布局或者模板中的错误，需在app目录下创建global-error.jsx
:::
